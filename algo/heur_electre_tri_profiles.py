from __future__ import division
import os, sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)) + "/../")
from mcda.types import alternative_performances
from mcda.types import performance_table

class heur_electre_tri_profiles():

    def __init__(self, crits, pt_sorted, aa, categories):
        self.crits = crits
        self.pt_sorted = pt_sorted
        self.aa = aa
        self.categories = categories
        self.delta = 0.0000001
        self.b0 = pt_sorted.get_worst_ap()
        self.compute_categories_probabilities()

    def compute_categories_probabilities(self):
        self.cat_proba = {}
        total = len(self.aa)
        for cat in self.categories.get_ordered_categories():
            aa_cat = self.aa.get_alternatives_in_category(cat)
            self.cat_proba[cat] = total - len(aa_cat)

    def compute_histogram(self, crit, cat_above, cat_below, above):
        h1 = {}
        h2 = {}
        below = self.b0.performances[crit.id]
        aids, perfs = self.pt_sorted.get_middle(crit.id, below, above)

        # From smallest to biggest
        val = 0
        for aid, perf in zip(aids, perfs):
            cat = self.aa[aid].category_id
            if cat == cat_below:
                val += self.cat_proba[cat]
                h1[perf + self.delta] = val
            elif cat == cat_above:
                h1[perf] = val

        # From biggest to smallest
        val = 0
        aids.reverse()
        perfs.reverse()
        for aid, perf in zip(aids, perfs):
            cat = self.aa[aid].category_id
            if cat == cat_above:
                val += self.cat_proba[cat]
                h2[perf] = val
            elif cat == cat_below:
                h2[perf + self.delta] = val

        return { key: h1[key] + h2[key] for key in h1 }

    def init_profile(self, profile_id, cat_above, cat_below, pabove):
        ap = alternative_performances(profile_id, {})
        for c in self.crits:
            perf = pabove.performances[c.id]
            h = self.compute_histogram(c, cat_above, cat_below, perf)
            if h:
                perf = max(h, key = lambda key: h[key])
            ap.performances[c.id] = perf

        return ap

    def solve(self):
        cats = self.categories.get_ordered_categories()
        cats.reverse()

        bpt = performance_table()
        pabove = self.pt_sorted.get_best_ap()
        for i in range(len(cats) - 1):
            profile_id = "b%d" % (len(cats) - (i + 1))
            bp = self.init_profile(profile_id, cats[i], cats[i+1], pabove)
            bpt.append(bp)
            pabove = bp

        return bpt

if __name__ == "__main__":
    from mcda.generate import generate_random_electre_tri_bm_model
    from mcda.generate import generate_alternatives
    from mcda.generate import generate_random_performance_table
    from mcda.generate import generate_random_profiles
    from mcda.pt_sorted import sorted_performance_table
    from mcda.utils import compute_ca
    from mcda.utils import compute_winning_coalitions
    from mcda.utils import display_coalitions
    from algo.lp_electre_tri_weights import lp_electre_tri_weights
    from ui.graphic import display_electre_tri_models

    model = generate_random_electre_tri_bm_model(10, 3, 17)
    coal = compute_winning_coalitions(model.cv, model.lbda)
    print("Number of coalitions: %d" % len(coal))

    a = generate_alternatives(1000)
    pt = generate_random_performance_table(a, model.criteria)
    sorted_pt = sorted_performance_table(pt)

    aa = model.pessimist(pt)

    for cat in model.categories_profiles.get_ordered_categories():
        pc = len(aa.get_alternatives_in_category(cat)) / len(aa) * 100
        print("Percentage of alternatives in %s: %g %%" % (cat, pc))

    cats = model.categories_profiles.to_categories()
    heur = heur_electre_tri_profiles(model.criteria, sorted_pt, aa, cats)
    learned_bpt = heur.solve()

    cps = model.categories_profiles

    # Learn the weights with random generated profiles
    for i in range(10):
        model2 = model.copy()
        b = model.categories_profiles.get_ordered_profiles()
        model2.bpt = generate_random_profiles(b, model2.criteria)

        lp_weights = lp_electre_tri_weights(model2, pt, aa, cps)
        lp_weights.solve()

        aa2 = model2.pessimist(pt)
        ca2 = compute_ca(aa, aa2)

        coal2 = compute_winning_coalitions(model2.cv, model2.lbda)
        coal2_ni = list((set(coal) ^ set(coal2)) & set(coal))
        coal2_add = list((set(coal) ^ set(coal2)) & set(coal2))

        print("Classification accuracy with random profiles: %g" % ca2)
        print("Coalitions: total: %d, common: %d, added: %d" % \
              (len(coal2), (len(coal) - len(coal2_ni)), len(coal2_add)))

    # Learn the weights with profiles generated by the heuristic
    model3 = model.copy()
    model3.bpt = learned_bpt

    lp_weights = lp_electre_tri_weights(model3, pt, aa, cps)
    lp_weights.solve()

    aa3 = model3.pessimist(pt)
    ca3 = compute_ca(aa, aa3)

    coal3 = compute_winning_coalitions(model3.cv, model3.lbda)
    coal3_ni = list((set(coal) ^ set(coal3)) & set(coal))
    coal3_add = list((set(coal) ^ set(coal3)) & set(coal3))

    print("Classification accuracy with heuristic: %g" % ca3)
    print("Coalitions: total: %d, common: %d, added: %d" % \
          (len(coal3), (len(coal) - len(coal3_ni)), len(coal3_add)))

    display_electre_tri_models([model], [pt.get_worst(model.criteria)],
                               [pt.get_best(model.criteria)],
                               [[ap for ap in learned_bpt]])
